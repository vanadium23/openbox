---
{"dg-publish":true,"up":"[[Books]]","title":"The Little Learner","category":"book","status":"Reviewing","tags":["books"],"rating":2,"date":"2023-02-20","modified_at":"2023-05-22T09:19:34+04:00","permalink":"/books/the-little-learner/","dgPassFrontmatter":true}
---




Кажется, что это будет книга без цитат. Она выполнена в режиме диалога между учителей и учеником. 

Первая глава посвящена языку Schemish (подмножество Racket / lisp). Рассказали про присвоение переменных, вызов функции и используют только рекурсию вместо циклов.

Вторая глава посвящена тензорам. В ней мы сначала говорим о линейной функции y = a\*x + b. А потом заворачиваем параметры в вектор. Вектор оказывается скаляром первого ранга, а нулевым рангом считаем обычные числа / скаляр. Для тензора мы утверждаем, что на одном уровне у нас всегда одинаковое количество элементов:
```
[ [ [1] [2] [3] ] [ [4] [5] [6] ] ]
```
У тензора есть два важных параметра - `rank` и `shape`.

Для того, чтобы провести линейную регрессию мы находим насколько далеко находятся наши точки от линейной функции с входными параметрами. А потом мы меняем параметры с помощью оценки относительной величины между увеличением ошибки и текущим значением параметров. 

Функция l2-loss из [[202304101724]] принимает на вход функцию для того, чтобы быть независимой от размерности, которую мы пытаемся аппроксимировать.

Вся попытка заключается в том, чтобы разделить три вещи: входные и выходные координаты, функцию к которой приближаем и параметры этой функции. Параметры как правило прячут за греческую букву θ. А большой обозначают параметр функции для нахождения параметров - Θ.

Для того, чтобы точно попасть в наши координаты нам необходимо замедляться по мере достижения локального оптимума. Здесь лежит беда переобучения, которая была упомянута в [[Верховный алгоритм]]. Для этого мы используем дополнительные параметр со скоростью и коэффициентом, который обычно лежит в диапазоне от 0 до 1 и начинается с 0.9.

Вторая половина книги начала описывать подход к построению [[нейронная сеть|нейронных сетей]]. Основный блоком в нейронной сети является функция активации, которая раскладывается на набор включенных и выключенных линейный функций. Под включением и выключением мы понимаем, что в каком-то диапазоне абсцисс наша функция даёт константу. Такими функциями мы можем нарезать любой график. 

В дизайне нейронных сетей складываются три параметра: количество входных данных (т.е. размерность входящей матрицы), количество выходных данных и количество нейронов. При разработке стоит начинать с выхода, так как здесь мы уже поймём сколько нам надо взять на финальном этапе и дальше разворачивать это до входа. 

Вопрос в том, как заложить начальные веса. Здесь мы сталкиваемся с набором проблем:
1. веса не могут быть одинаковыми, иначе у нас получится так, что мы не сможем различить ответы, когда они пройдут через слои нейросети
2. веса не могут быть очень большими, потому что тогда они будут любой входящий сигнал приводить в шум
3. веса не могут быть очень маленькими, потому что тогда они потеряют совсем входящий параметр


## Цитаты

- [[202304021732|202304021732]]: \-
- [[202304101724|202304101724]]: \-
- [[202304101732|202304101732]]: \-
- [[202305150945|202305150945]]: \-
- [[202305161024|202305161024]]: \-
- [[202305170953|202305170953]]: \-
- [[202305170956|202305170956]]: \-
- [[202305180950|202305180950]]: \-
- [[202305181000|202305181000]]: \-


## Задачи

- [ ] #task Обработать все выдержки из книги в рамках Zettels
- [ ] #task Написать выдержку из книги
- [ ] #task Доработать свои заметки на основе идей из книг
