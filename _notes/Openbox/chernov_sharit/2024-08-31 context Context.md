---
{"dg-publish":true,"up":"[[Chernov sharit]]","date":"2024-08-31","posted":"https://t.me/chernov_sharit/631","modified_at":"2024-09-10T22:40:49+03:00","published_at":"2024-08-31T19:05:00+03:00","dg-path":"/chernov_sharit/2024-08-31 context Context.md","permalink":"/chernov-sharit/2024-08-31-context-context/","dgPassFrontmatter":true}
---


### **(089/100) context.Context**

Некоторые вещи в golang так сильно бесят, что в итоге нравятся. Вот эти постоянные шутки про `err != nil`, хотя это учит разработчиков думать про ошибки. Вот вторая штука - это `context.Context`. 

Пойду здесь в не совсем корректную аналогию, потому что асинхронное/async не тоже самое что конкурентное/concurrent исполнение, но дизайн элементов решает схожие задачи. Как делают 80% языков? Асинхронная функция верёт тебе промис/Future/корутину, и ты должен её вызвать. Управление потоком ведётся скорее языком, ну или тебе вытащат таймаут/cancel. К чему приводит дальше - https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/.

В golang решили пойти своим путём (иногда это плохо смотри text/template или форматирование дат). Мы засовываем горутину в миксер рантайма через ключевое слово `go`, и управлять можем через ~~каналы~~ контекст. Это даёт два положительных момента:
1. сигнатура функции говорит нам об её отменяемости
2. управление отменой лежит на вызывающем, обработка отмены на вызванном

Ключевой вопрос здесь - сколько оставлять на пользовательский уровень, а сколько должен делать рантайм?

#марафон  @chernov_sharit
